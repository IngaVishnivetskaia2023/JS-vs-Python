### Функции как "first-class citizen" или "объекты первого класса"
:white_check_mark: JS :white_check_mark: Python

Объекты первого класса: элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной.

```
def add(x,y):
 return x + y
```

### Параметры по умолчанию
:white_check_mark: JS :white_check_mark: Python

:heavy_exclamation_mark: **Python** значения по умолчанию вычисляются **один раз при обьявлении функции**, 
это не создаёт никаких проблем, если вы в качестве значения по умолчанию передаёте неизменяемые данные, 
а если передаются изменяемые данные или динамическое значение, то результат будем неожиданным.
```
def foo(x, items=[]):
 items.append(x)
 return items
foo(1)
foo(2)
result = foo(3)
print(result) // [1,2,3]
```

В Javascript параметры по умолчанию вычисляются **в момент вызова функции**. 
В отличие от языка Python, при каждом вызове функции создаётся **новое лексическое окружение функции**.
```
function append(value, array = []) {
  array.push(value);
  return array;
}

append(1); // [1]
append(2); // [2], а не [1, 2]
```

### Именованные аргументы в Python vs объект как параметр в JS
При вызове с именованными аргументами порядок следования аргументов не имеет значения.
```
def foo(w,x,y,z):
 инструкции
# Вызов с именованными аргументами
foo(x=3, y=22, w=’hello’, z=[1,2])
```

Именованные аргументы Python не имеют отношения к arguments JS. Это альтернативная техника работы с аргументами, которая позволяет обращаться к ним по имени, а не по номеру.
В JavaScript именованные параметры реализуются при помощи объекта.

:heavy_exclamation_mark:  В JS в параметрах по умолчанию можно использовать значения предыдущих (расположенных левее в списке) параметров:
```
function greet(name, greeting, message = greeting + " " + name) {
  return [name, greeting, message];
}

greet("David", "Hi"); // ["David", "Hi", "Hi David"]
greet("David", "Hi", "Happy Birthday!"); // ["David", "Hi", "Happy Birthday!"]
```




### Итераторы и генераторы

### JavaScript

ES6 important features: iterators, generators, modules, and classes.

Чтобы объект стал **итерабельным**, он должен применять **итерабельный протокол**, 
то есть объект (или один из объектов выше по цепочке прототипов) должен иметь **свойство** с **ключом Symbol.iterator**.

`Symbol.iterator` — это **уникальный символ, предопределенный в JavaScript**, который используется для определения итераторов.

Если объект стал итерабельным, то он поддерживает итерацию с помощью `for...of`, `spread (...)`, `Array.from()`.

Когда объект имеет свойство с ключом `Symbol.iterator`, то это свойство должно быть **функцией**.
Эта функция возвращает **итератор** — объект с методом `next()`, возвращающим `{ value, done }`.

```
const iterableObject = {
  data: [10, 20, 30],
  [Symbol.iterator]() {
    let index = 0;
    return {                           // возвращает итератор!!!
      next: () => {                    // Итератор реализует метод next(), который управляет последовательностью значений
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for (const num of iterableObject) {
  console.log(num); // 10, 20, 30
}
```

Примечания:
- `index++` сначала возвращает `this.data[0]`, а затем увеличивает `step`.
- Это называется постфиксный инкремент (`index++`), и он работает так же в `return`.
- В следующем вызове `next()` index уже будет увеличенным (1, 2, 3 и т. д.).

#### Итерация встроенных объектов
Некоторые встроенные объекты в `JavaScript` уже содержат `Symbol.iterator`, например:

- Массивы (Array)
- Строки (String)
- Map
- Set

```
const arr = [1, 2, 3];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { done: true }
```


